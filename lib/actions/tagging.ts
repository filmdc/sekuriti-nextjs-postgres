'use server';

import { redirect } from 'next/navigation';
import { revalidatePath } from 'next/cache';
import { z } from 'zod';
import { getUser } from '@/lib/db/queries';
import {
  createTag,
  updateTag,
  deleteTag,
  mergeTags,
  getTagsByOrganization
} from '@/lib/db/queries-tags';\nimport { \n  addTagsToAsset, \n  removeTagsFromAsset, \n  bulkTagAssets \n} from '@/lib/db/queries-assets';\nimport { validatedAction, validatedActionWithUser } from '@/lib/auth/middleware';\nimport { logActivity } from '@/lib/audit';\n\n// Schema definitions\nconst createTagSchema = z.object({\n  name: z.string().min(1, 'Tag name is required').max(50, 'Tag name too long'),\n  category: z.enum(['location', 'department', 'criticality', 'compliance', 'incident_type', 'skill', 'custom']).default('custom'),\n  color: z.string().regex(/^#[0-9A-F]{6}$/i, 'Invalid color format').default('#6B7280'),\n  description: z.string().optional().nullable()\n});\n\nconst updateTagSchema = z.object({\n  id: z.number(),\n  name: z.string().min(1, 'Tag name is required').max(50, 'Tag name too long').optional(),\n  category: z.enum(['location', 'department', 'criticality', 'compliance', 'incident_type', 'skill', 'custom']).optional(),\n  color: z.string().regex(/^#[0-9A-F]{6}$/i, 'Invalid color format').optional(),\n  description: z.string().optional().nullable()\n});\n\nconst deleteTagSchema = z.object({\n  id: z.number()\n});\n\nconst mergeTagsSchema = z.object({\n  sourceTagId: z.number(),\n  targetTagId: z.number()\n});\n\nconst assetTaggingSchema = z.object({\n  assetId: z.number(),\n  tagIds: z.array(z.number()).min(1, 'At least one tag must be provided')\n});\n\nconst bulkTaggingSchema = z.object({\n  assetIds: z.array(z.number()).min(1, 'At least one asset must be provided'),\n  tagIds: z.array(z.number()).min(1, 'At least one tag must be provided'),\n  action: z.enum(['add', 'remove']).default('add')\n});\n\nconst createTagTemplateSchema = z.object({\n  name: z.string().min(1, 'Template name is required').max(100, 'Template name too long'),\n  description: z.string().optional().nullable(),\n  tags: z.array(z.number()).min(1, 'At least one tag must be provided'),\n  entityType: z.string().optional().nullable(),\n  isDefault: z.boolean().default(false)\n});\n\n// Tag CRUD actions\nexport const createTagAction = validatedActionWithUser(\n  createTagSchema,\n  async (data, user) => {\n    try {\n      const tag = await createTag({\n        ...data,\n        organizationId: user.teamId\n      });\n\n      await logActivity({\n        type: 'tag.created',\n        userId: user.id,\n        teamId: user.teamId,\n        metadata: {\n          tagId: tag.id,\n          tagName: tag.name,\n          category: tag.category\n        }\n      });\n\n      revalidatePath('/assets');\n      return { success: true, tag };\n    } catch (error) {\n      console.error('Error creating tag:', error);\n      return { \n        success: false, \n        error: error instanceof Error ? error.message : 'Failed to create tag' \n      };\n    }\n  }\n);\n\nexport const updateTagAction = validatedActionWithUser(\n  updateTagSchema,\n  async (data, user) => {\n    try {\n      const { id, ...updateData } = data;\n      const tag = await updateTag(id, user.teamId, updateData);\n\n      if (!tag) {\n        return { success: false, error: 'Tag not found' };\n      }\n\n      await logActivity({\n        type: 'tag.updated',\n        userId: user.id,\n        teamId: user.teamId,\n        metadata: {\n          tagId: tag.id,\n          tagName: tag.name,\n          changes: updateData\n        }\n      });\n\n      revalidatePath('/assets');\n      return { success: true, tag };\n    } catch (error) {\n      console.error('Error updating tag:', error);\n      return { \n        success: false, \n        error: error instanceof Error ? error.message : 'Failed to update tag' \n      };\n    }\n  }\n);\n\nexport const deleteTagAction = validatedActionWithUser(\n  deleteTagSchema,\n  async (data, user) => {\n    try {\n      const tag = await deleteTag(data.id, user.teamId);\n\n      if (!tag) {\n        return { success: false, error: 'Tag not found or cannot be deleted' };\n      }\n\n      await logActivity({\n        type: 'tag.deleted',\n        userId: user.id,\n        teamId: user.teamId,\n        metadata: {\n          tagId: tag.id,\n          tagName: tag.name\n        }\n      });\n\n      revalidatePath('/assets');\n      return { success: true };\n    } catch (error) {\n      console.error('Error deleting tag:', error);\n      return { \n        success: false, \n        error: error instanceof Error ? error.message : 'Failed to delete tag' \n      };\n    }\n  }\n);\n\nexport const mergeTagsAction = validatedActionWithUser(\n  mergeTagsSchema,\n  async (data, user) => {\n    try {\n      await mergeTags(data.sourceTagId, data.targetTagId, user.teamId);\n\n      await logActivity({\n        type: 'tag.merged',\n        userId: user.id,\n        teamId: user.teamId,\n        metadata: {\n          sourceTagId: data.sourceTagId,\n          targetTagId: data.targetTagId\n        }\n      });\n\n      revalidatePath('/assets');\n      return { success: true };\n    } catch (error) {\n      console.error('Error merging tags:', error);\n      return { \n        success: false, \n        error: error instanceof Error ? error.message : 'Failed to merge tags' \n      };\n    }\n  }\n);\n\n// Asset tagging actions\nexport const addTagsToAssetAction = validatedActionWithUser(\n  assetTaggingSchema,\n  async (data, user) => {\n    try {\n      await addTagsToAsset(data.assetId, data.tagIds, user.teamId);\n\n      await logActivity({\n        type: 'asset.tagged',\n        userId: user.id,\n        teamId: user.teamId,\n        metadata: {\n          assetId: data.assetId,\n          tagIds: data.tagIds,\n          action: 'add'\n        }\n      });\n\n      revalidatePath(`/assets/${data.assetId}`);\n      revalidatePath('/assets');\n      return { success: true };\n    } catch (error) {\n      console.error('Error adding tags to asset:', error);\n      return { \n        success: false, \n        error: error instanceof Error ? error.message : 'Failed to add tags to asset' \n      };\n    }\n  }\n);\n\nexport const removeTagsFromAssetAction = validatedActionWithUser(\n  assetTaggingSchema,\n  async (data, user) => {\n    try {\n      await removeTagsFromAsset(data.assetId, data.tagIds);\n\n      await logActivity({\n        type: 'asset.untagged',\n        userId: user.id,\n        teamId: user.teamId,\n        metadata: {\n          assetId: data.assetId,\n          tagIds: data.tagIds,\n          action: 'remove'\n        }\n      });\n\n      revalidatePath(`/assets/${data.assetId}`);\n      revalidatePath('/assets');\n      return { success: true };\n    } catch (error) {\n      console.error('Error removing tags from asset:', error);\n      return { \n        success: false, \n        error: error instanceof Error ? error.message : 'Failed to remove tags from asset' \n      };\n    }\n  }\n);\n\nexport const bulkTagAssetsAction = validatedActionWithUser(\n  bulkTaggingSchema,\n  async (data, user) => {\n    try {\n      if (data.action === 'add') {\n        await bulkTagAssets(data.assetIds, data.tagIds, user.teamId);\n      } else {\n        // Remove tags from each asset individually\n        for (const assetId of data.assetIds) {\n          await removeTagsFromAsset(assetId, data.tagIds);\n        }\n      }\n\n      await logActivity({\n        type: 'asset.bulk_tagged',\n        userId: user.id,\n        teamId: user.teamId,\n        metadata: {\n          assetIds: data.assetIds,\n          tagIds: data.tagIds,\n          action: data.action,\n          count: data.assetIds.length\n        }\n      });\n\n      revalidatePath('/assets');\n      return { \n        success: true, \n        message: `${data.action === 'add' ? 'Added' : 'Removed'} ${data.tagIds.length} tag(s) ${data.action === 'add' ? 'to' : 'from'} ${data.assetIds.length} asset(s)` \n      };\n    } catch (error) {\n      console.error('Error bulk tagging assets:', error);\n      return { \n        success: false, \n        error: error instanceof Error ? error.message : 'Failed to update asset tags' \n      };\n    }\n  }\n);\n\n// Tag template actions\nexport const createTagTemplateAction = validatedActionWithUser(\n  createTagTemplateSchema,\n  async (data, user) => {\n    try {\n      // This would require implementing the tag template creation in queries-tags.ts\n      // For now, we'll just log the action\n      await logActivity({\n        type: 'tag_template.created',\n        userId: user.id,\n        teamId: user.teamId,\n        metadata: {\n          templateName: data.name,\n          tagCount: data.tags.length,\n          entityType: data.entityType\n        }\n      });\n\n      return { success: true };\n    } catch (error) {\n      console.error('Error creating tag template:', error);\n      return { \n        success: false, \n        error: error instanceof Error ? error.message : 'Failed to create tag template' \n      };\n    }\n  }\n);\n\n// Utility actions\nexport const getTagSuggestionsAction = async (assetType: string, existingTagIds: number[] = []) => {\n  try {\n    const user = await getUser();\n    if (!user?.teamId) {\n      return { success: false, error: 'Unauthorized' };\n    }\n\n    const allTags = await getTagsByOrganization(user.teamId);\n    \n    // Filter out already assigned tags\n    const availableTags = allTags.filter(tag => !existingTagIds.includes(tag.id));\n    \n    // Simple suggestion logic based on asset type\n    const suggestions = availableTags.filter(tag => {\n      switch (assetType) {\n        case 'hardware':\n          return tag.category === 'location' || \n                 tag.category === 'criticality' ||\n                 tag.name.toLowerCase().includes('physical');\n        case 'software':\n          return tag.category === 'department' || \n                 tag.name.toLowerCase().includes('application');\n        case 'service':\n          return tag.name.toLowerCase().includes('external') ||\n                 tag.name.toLowerCase().includes('cloud');\n        default:\n          return tag.category === 'criticality' || tag.category === 'department';\n      }\n    }).slice(0, 5);\n\n    return { success: true, suggestions };\n  } catch (error) {\n    console.error('Error getting tag suggestions:', error);\n    return { \n      success: false, \n      error: error instanceof Error ? error.message : 'Failed to get tag suggestions' \n    };\n  }\n};\n\nexport const searchTagsAction = async (query: string, category?: string) => {\n  try {\n    const user = await getUser();\n    if (!user?.teamId) {\n      return { success: false, error: 'Unauthorized' };\n    }\n\n    const allTags = await getTagsByOrganization(user.teamId);\n    \n    const filteredTags = allTags.filter(tag => {\n      const matchesQuery = tag.name.toLowerCase().includes(query.toLowerCase());\n      const matchesCategory = !category || tag.category === category;\n      return matchesQuery && matchesCategory;\n    });\n\n    return { success: true, tags: filteredTags };\n  } catch (error) {\n    console.error('Error searching tags:', error);\n    return { \n      success: false, \n      error: error instanceof Error ? error.message : 'Failed to search tags' \n    };\n  }\n};